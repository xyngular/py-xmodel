{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#getting-started","title":"Getting Started","text":"Alpha Software! <p>This is pre-release Alpha software, based on another code base and the needed changes to make a final release version are not yet completed. Everything is subject to change!</p> <pre><code>poetry install xmodel\n</code></pre> <p>or</p> <pre><code>pip install xmodel\n</code></pre> <p>Very basic example:</p> <pre><code>from xmodel import JsonModel\n\nclass MyModel(JsonModel):\n    some_attr: str\n\njson_dict_input = {'some_attr': 'a-value'}    \n\nobj = MyModel(json_dict_input)\nassert obj.some_attr == 'a-value'\n\njson_dict = obj.api.json()\nassert json_dict == json_dict_input\n</code></pre> <p>Also, an abstract RemoteModel interface used in xmodel-rest and xdynamo along with some common code.</p> <ul> <li>Install in Python project</li> <li>Poetry<ul> <li>Gemfury</li> <li>Git URL</li> </ul> </li> <li>Development</li> <li>How To Use</li> </ul>"},{"location":"#install-in-python-project","title":"Install in Python project","text":"<p>This can be installed from git URLs or from gemfury in the <code>pyproject.toml</code> file.</p> <p>You see the documentation locally by doing this in the project root folder with <code>repoman</code> installed  locally:</p> <pre><code>repo install\nrepo docs --live\n</code></pre>"},{"location":"#poetry","title":"Poetry","text":"<p>You can install this using gemfury</p>"},{"location":"#development","title":"Development","text":"<p>How to develop this library. </p> <p>Requires <code>repoman</code> to be installed locally</p> <ul> <li>Install dependencies for development with <code>repo install</code></li> <li>Run tests with <code>repo test</code></li> <li>See documentation with <code>repo docs --live</code> (see <code>repo docs --help</code> on how to configure locally)</li> </ul>"},{"location":"#how-to-use","title":"How To Use","text":"<p>.. todo::  This is incomplete, need to put more in here, especially about the remote model.     Also, the docs for some classes in this library are a bit out of date (very alpha software).</p> <p>The basic use-case of this library is with <code>JsonModel</code>, which allows you to map an object to/from a json dict with various options to control how it maps, converting values to pyhton native types.</p> <p>It can also keep track of changes you make to the model object compared to the Json values it has gotten.</p> <p>Here is a basic overview of working with a JsonModel subclass, as a series of code-examples that build on-top of each-other with a number of code comments to explain what's happening:</p> <pre><code>from xmodel import JsonModel\nfrom decimal import Decimal\n\nclass MyModel(JsonModel):\n    first_name: str\n    volume: int\n    price: Decimal\n\njson = {\n    'first_name': 'Darius',\n    'volume': 20,\n    'price': '10.4'\n}\n\n# First positional argument for a JsonModel is an optional Json Dict.\n# It turns around and simply calls `self.api.update_from_json` for you\n# with the dict you pass in.\nmodel = MyModel(json)\n\n# After updating model from json, the values are all set.\nassert model.first_name == 'Darius'\nassert model.volume == 20\nassert model.price == Decimal('10.4')\n\n# JsonModel's keep track of the orginal JSON values, it compares the values\n# to what the values are in it's attributes and can return what actaully changed.\n# If nothing has changed, it returns a None.\n#\n# Returns None because no changes vs the inital JSON were made.\nassert model.api.json(only_include_changes=True) is None\n\n# Converts to Decimal(30) for you when you set it on object.\nmodel.price = 30\nassert model.price == Decimal(30)\n\n# Now when you ask it for changes, it includes the change:\nassert model.api.json(only_include_changes=True) == {'price': '30'}\n\n# Update values with a partial JSON object, it only updates what's inside json dict,\n# leaves other values alone.\nmodel.api.update_from_json({'first_name': 'new-name'})\n\nassert model.first_name == 'new-name'\n\n# We still have that price change because we have not updated it with the new json-value yet.\nassert model.api.json(only_include_changes=True) is None == {'price': '30'}\n\n# It's pretty common when you send values to an API, the server will return what the current\n# values are for the object. You can just pipe that into `update_from_json` to update the\n# object from it's JSON values.\n#\n# This also records the orginal json-value, per-key, to compare against for\n# the `only_include_changes` option.\nmodel.api.update_from_json({'first_name': 'new-name'})\n\n\n# Returns None because no changes vs what it has recoded as the original JSON values:\nassert model.api.json(only_include_changes=True) is None\n</code></pre>"},{"location":"#sub-models","title":"Sub-Models","text":"<p>You can type-hint to another JsonModel, if you do it will embed the object when you ask for the objects JSON.</p> <p>It can also update it's self and the embedded-JsonModel object for you when you update it from a Json dict.</p> <pre><code>from xmodel import JsonModel\nfrom decimal import Decimal\n\nclass Address(JsonModel):\n    street: str\n    city: str\n\nclass Account(JsonModel):\n    first_name: str\n    address: Address\n\njson = {\n    'first_name': 'customer-name',\n    'address': {'street': '123 Frost Ave', city: 'Lehi'}\n}\n\naccount = Account(json)\n\nassert account.address.street == '123 Frost Ave'\n\n# If you ask for json, should return same values it was given\nassert account.api.json() == json\n\n# No changes vs orginal values, so returns None\nassert account.api.json(only_include_changes=True) is None\n\n# We make a change to sub-object\naccount.address.street = 'changed-street'\n\n# Now when we ask for changes, it includes on the sub-object change.\nassert account.api.json(only_include_changes=True) == {'address': {'street': 'changed-street'}}\n</code></pre>"},{"location":"#remote-abstract-interface","title":"Remote Abstract Interface","text":"<p>I'll briefly mention the <code>xmodel.remote</code> module and the <code>RemoteModel</code></p> <p>It contains a set of common code and an abstract interface that can be used to implment remote retreival and sending of JsonModel-type objects.</p> <p>We have two current concreate implementations:</p> <ul> <li>xmodel-rest: Useful for rest-api's</li> <li>xdynamo: Useful for model objects in dynamo tables.</li> </ul> <p>The abstract interface includes a basic way to ask for an object by id, and a way to send object updates back to API.</p> <p>This makes it so JsonModel knows how lazily retrieve <code>RemoteModel</code>'s if it encounters one as a sub-object on it's self. It simply calls the correct abstract method, which should be a concreate implementation of the RemoteModel and related classes, abstract interfaces.</p> <p>I won't say much more about it here. See relevant classes/modules doc-comments for more details. You can also look at xmodel-rest and xdynamo for concreate, real-world implementations.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":""},{"location":"changelog/#070-2023-09-15","title":"0.7.0 (2023-09-15)","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>remove unneeded dependency. (ab67b1d)</li> </ul>"},{"location":"changelog/#060-2023-05-19","title":"0.6.0 (2023-05-19)","text":""},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>allow json-strarg as first positional argument for BaseModel. (4278518)</li> </ul>"},{"location":"changelog/#050-2023-05-05","title":"0.5.0 (2023-05-05)","text":""},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>lazily copy any default-BaseModel instance when needed. (f26bfd0)</li> </ul>"},{"location":"changelog/#041-2023-05-04","title":"0.4.1 (2023-05-04)","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Ensure model/instance-ties BaseApi has default-converters from Class-tied BaseApi object. (d77aecd)</li> </ul>"},{"location":"changelog/#040-2023-05-02","title":"0.4.0 (2023-05-02)","text":""},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>support <code>Self</code> and <code>dataclass-transforms</code> from Python 3.11 (python &lt; 3.11 still works). (f9dd9ef)</li> </ul>"},{"location":"changelog/#031-2023-04-15","title":"0.3.1 (2023-04-15)","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>license (c1fea47)</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>add doc links. (2beff5c)</li> </ul>"},{"location":"changelog/#030-2023-04-15","title":"0.3.0 (2023-04-15)","text":""},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li>fix doc title. (7df4e84)</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>don't iterate dicts. (4ca409d)</li> </ul>"},{"location":"changelog/#020-2023-04-13","title":"0.2.0 (2023-04-13)","text":""},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>allow later versions of python. (5e93b10)</li> </ul>"},{"location":"changelog/#011-2023-04-08","title":"0.1.1 (2023-04-08)","text":""},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>doc generator. (f6f9e0c)</li> </ul>"},{"location":"changelog/#010-2023-04-08","title":"0.1.0 (2023-04-08)","text":""},{"location":"changelog/#features_6","title":"Features","text":"<ul> <li>add tomlkit to dev deps. (0226c6e)</li> <li>add workflows (c4810eb)</li> <li>fix refrences (9259f18)</li> <li>initial imported code (9981452)</li> <li>rename error classes (8764e0b)</li> </ul>"},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>various refs fixed up. (7746cb6)</li> </ul>"}]}